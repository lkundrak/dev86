*** WORK IN PROGRESS ***


MON86 is yet another monitor for a 8086/8088/80186/80188 based system.

That old 16-bits processor architecture is still used in some devices
(micro-controllers, SBC, SoC, etc) that reuse the huge hardware and code
base from the legacy PC/XT/AT platform.

The monitor is a tool used on such embedded systems to take control of the
target just after booting, and before loading / executing a more complex
software like a native application or an operating system.

It provides basic functions, such as read / write the registers, read / write
the memory, and execute code. It optionally allows to execute code step by
step, or to put breakpoints, when acting as a master task.

MON86 is either loaded into the target RAM by the bootloader from any suitable
device, or burned into the EEPROM / Flash for direct execution.

It communicates with the development system through the simplest and available
interface (typically the asynchronous serial port), and with the simplest
protocol.

Since that protocol only supports basic operations, the monitor could be in
turn drived from the development system by the some utilities, to implement
more complex and user-friendly commands, like loading and run an executable.


MASTER AND SLAVE TASKS

In order to minimize as much as possible the side-effect of the monitor on the
the tested code, it can acts as a master that controls a slave task, each of
them having their own execution context. Context switching is performed with
the help of the trace / break 8086 interrupts (INT01h and INT03h).


CONTEXT SWITCHING

Context registers are saved on the top of the task stack, following an order
that eases the context switching and the interrupt handling. For the slave,
they are followed by the master return address, to allow to terminate and to
give control back to the master through a simple RETF / IRET.

Stack before SS:SP switch:

  Offset  Register or value
  00      AX
  02      CX
  04      DX
  06      BX
  08      SP (dummy)
  0A      BP
  0C      SI
  0E      DI
  10      ES
  12      CS (dummy)
  14      SS (dummy)
  16      DS
  18      IP (dummy)
  1A      FL (dummy)
  1C      interrupt number
  1E      IP slave
  20      CS slave
  22      FL slave
  24      IP master
  26      CS master
  28      FL master

Remaining of the context data is stored in a static structure pointed by the
vector [0:3FCh] (INT FFh):

  Offset  Register or value
  00      magic as NOP IRET to protect against INT FFh
  02      SP slave
  04      SS slave
  06      SP master
  08      SS master
  0A      slave run flag
  0B      slave returned flag


SERIAL COMMUNICATION PROTOCOL

The monitor receives ASCII characters from the serial interface and groups them
by tokens. All characters are converted to uppercase. The tokens are separated
by at least one space (any character code <= 32 is translated into a space).

Each token is either an immediate value as an hexadecimal number (4 digits max,
without any prefix nor suffix), or a command with a concatenated prefix letter,
and a suffix letter or an hexadecimal digit.

The commands are ('i' is the register or routine index):
	O   Set the offset
	S   Set the segment
	L   Set the length (reserved)
	R   Read byte from [segment:offset]
	W   Write byte to [segment:offset]
	Ji  Get the register (i)
	Ki  Set the register (i)
	P   Call the far procedure at [segment:offset]
	T   Execute the slave task

  Index  Register
  0      AX
  1      CX
  2      DX
  3      BX
  4      SP
  5      BP
  6      SI
  7      DI
  8      ES
  9      CS
  A      SS
  B      DS
  C      IP
  D      FL

A command uses the previous immediate value, which is saved to avoid repeating
it for the next command.

After each immediate value or command, the monitor writes a status with the same
format as a command, with the 'Z' prefix:

	Z0  success
	Z1  end of stream
	Z2  bad token length
	Z3  bad token value
	Z4  bad index
	Z5  slave interrupted by trace (INT 01h)
	Z6  slave interrupted by break (INT 03h)
	Z7  slave returned by RETF or IRET


Example 1: read 3 bytes from [1234h:5678h] that contains bytes AAh, BBh and CCh:
'1234 S 5678 O R R R' returns 'Z0 Z0 Z0 Z0 AA Z0 BB Z0 CC Z0'

Example 2: write 3 bytes AAh, BBh and CCh to [1234h:5678h]
'1234 S 5678 O AA W BB W CC W' returns 'Z0 Z0 Z0 Z0 Z0 Z0 Z0 Z0 Z0 Z0'

Example 3: call far procedure at [1234h:5678h]
'1234 S 5678 O P' returns 'Z0 Z0 Z0 Z0 Z0'

Example 4: start slave in trace mode at [1000h:0] with data/stack in segment 2000
'2000 K8 KA KB 1000 K9' : set CS=1000h and DS=ES=SS=2000h
'0 K4 KC'               : set IP=SP=0
'100 KD T'              : set TF flag and start slave
